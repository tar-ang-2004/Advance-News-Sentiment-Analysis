<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sentiment Prediction Graph</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            background: #1a1a1a;
            color: #ffffff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
        }
        .graph-container {
            background: #2d2d2d;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
            height: 80vh;
        }
        .graph-title {
            text-align: center;
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 30px;
            background: linear-gradient(45deg, #00ff88, #00ccff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .sentiment-value {
            text-align: center;
            font-size: 3rem;
            font-weight: bold;
            margin-bottom: 20px;
        }
        .positive { color: #00ff88; }
        .negative { color: #ff4757; }
        .neutral { color: #ffa502; }
        #sentimentChart {
            background: #1a1a1a;
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <div class="container-fluid">
        <div class="graph-container">
            <h1 class="graph-title">Sentiment Prediction Results</h1>
            
            <div class="sentiment-value" id="currentSentiment">
                <span class="neutral">Waiting for data...</span>
            </div>
            
            <div style="height: 500px; position: relative;">
                <canvas id="sentimentChart"></canvas>
            </div>
            
            <div class="text-center mt-3">
                <small class="text-muted">Live sentiment analysis results • Updates automatically</small>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.3.0/dist/chart.min.js"></script>
    <script>
        // Fallback for Chart.js if primary CDN fails
        if (typeof Chart === 'undefined') {
            document.write('<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.3.0/chart.min.js"><\/script>');
        }
    </script>
    <script>
        let sentimentChart = null;
        let sentimentData = [];
        let timeLabels = [];

        // Wait for Chart.js to load before initializing
        function initializeDashboard() {
            if (typeof Chart === 'undefined') {
                console.warn('Chart.js not loaded, retrying in 500ms...');
                setTimeout(initializeDashboard, 500);
                return;
            }
            console.log('Chart.js loaded successfully');
            initializeChart();
            loadDashboardData();
        }

        function initializeChart() {
            const ctx = document.getElementById('sentimentChart');
            
            sentimentChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: timeLabels,
                    datasets: [{
                        label: 'Sentiment Score',
                        data: sentimentData,
                        borderColor: function(context) {
                            const value = context.parsed.y;
                            if (value > 0.6) return '#00ff88';
                            if (value < 0.4) return '#ff4757';
                            return '#ffa502';
                        },
                        backgroundColor: function(context) {
                            const value = context.parsed.y;
                            if (value > 0.6) return 'rgba(0, 255, 136, 0.1)';
                            if (value < 0.4) return 'rgba(255, 71, 87, 0.1)';
                            return 'rgba(255, 165, 2, 0.1)';
                        },
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4,
                        pointBackgroundColor: function(context) {
                            const value = context.parsed.y;
                            if (value > 0.6) return '#00ff88';
                            if (value < 0.4) return '#ff4757';
                            return '#ffa502';
                        },
                        pointBorderColor: '#ffffff',
                        pointBorderWidth: 2,
                        pointRadius: 5,
                        pointHoverRadius: 8
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: '#ffffff',
                            bodyColor: '#ffffff',
                            borderColor: '#444444',
                            borderWidth: 1,
                            displayColors: false,
                            callbacks: {
                                label: function(context) {
                                    const value = context.parsed.y;
                                    const sentiment = value > 0.6 ? 'Positive' : value < 0.4 ? 'Negative' : 'Neutral';
                                    return `${sentiment}: ${(value * 100).toFixed(1)}%`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: {
                                color: '#333333',
                                drawBorder: false
                            },
                            ticks: {
                                color: '#888888',
                                maxTicksLimit: 10
                            }
                        },
                        y: {
                            min: 0,
                            max: 1,
                            grid: {
                                color: '#333333',
                                drawBorder: false
                            },
                            ticks: {
                                color: '#888888',
                                callback: function(value) {
                                    return (value * 100).toFixed(0) + '%';
                                }
                            }
                        }
                    },
                    animation: {
                        duration: 1000,
                        easing: 'easeInOutQuart'
                    }
                }
            });
        }

        async function loadDashboardData() {
            try {
                console.log('Loading dashboard data...');
                const response = await fetch('/dashboard-data');
                const data = await response.json();
                
                console.log('Dashboard data received:', data);
                
                updateChart(data);
                updateCurrentSentiment(data);
                
            } catch (error) {
                console.error('Error loading dashboard data:', error);
            }
        }

        function updateChart(data) {
            if (!sentimentChart || !data.recent_analyses) return;

            // Clear existing data
            sentimentData = [];
            timeLabels = [];

            // Process recent analyses (last 20 for better visualization)
            const analyses = data.recent_analyses.slice(-20);
            
            analyses.forEach((analysis, index) => {
                // Convert sentiment to score (positive = higher score)
                const sentimentScore = analysis.sentiment === 'positive' ? 
                    0.5 + (analysis.confidence * 0.5) : 
                    0.5 - (analysis.confidence * 0.5);
                
                sentimentData.push(sentimentScore);
                
                // Format timestamp
                const timestamp = new Date(analysis.timestamp);
                timeLabels.push(timestamp.toLocaleTimeString());
            });

            // Update chart data
            sentimentChart.data.labels = timeLabels;
            sentimentChart.data.datasets[0].data = sentimentData;
            
            // Update colors based on data
            sentimentChart.data.datasets[0].borderColor = sentimentData.map(value => {
                if (value > 0.6) return '#00ff88';
                if (value < 0.4) return '#ff4757';
                return '#ffa502';
            });
            
            sentimentChart.update('active');
        }

        function updateCurrentSentiment(data) {
            const currentElement = document.getElementById('currentSentiment');
            
            if (!data.recent_analyses || data.recent_analyses.length === 0) {
                currentElement.innerHTML = '<span class="neutral">No data available</span>';
                return;
            }

            const latest = data.recent_analyses[0];
            const isPositive = latest.sentiment === 'positive';
            const confidence = (latest.confidence * 100).toFixed(1);
            
            const sentimentClass = isPositive ? 'positive' : 'negative';
            const sentimentText = isPositive ? 'POSITIVE' : 'NEGATIVE';
            const arrow = isPositive ? '↗️' : '↘️';
            
            currentElement.innerHTML = `
                <span class="${sentimentClass}">
                    ${arrow} ${sentimentText} ${confidence}%
                </span>
            `;
        }

        // Load dashboard data on page load
        document.addEventListener('DOMContentLoaded', initializeDashboard);

        // Auto-refresh every 10 seconds for real-time updates
        setInterval(loadDashboardData, 10000);
    </script>
</body>
</html>
